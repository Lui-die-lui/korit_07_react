현재 New Car 버튼을 클릭했을 때 Modal이 나오면서 빈 input 태그들이 뜹니다. 여기에 정보를 입력할 수 있는 상태입니다.

그런데 각 row 맨 마지막 컬럼으로 Edit 버튼을 추가해서 일부 수정을 가능하게끔 할 예정입니다. 그리고 이때도 Modal이 뜨게끔 하거구요

그렇다면 New Car에서 사용하는 Modal을 Edit에서도 동일하게 쓸 수 있을 것 같습니다. 블로그를 작성할 때 새로 발행하기만하면 빈 양식으로 뜨는데, 수정하기 하면 똑같은 양식 튀어나오지만 내용 그대로 나오는것과 동일

```tsx
import { ChangeEvent } from "react";
import { Car } from "../types"

type DialogFormProps = { //dto 정도로 생각해주면 됨
  car: Car;
  // input 있으면ChangeEvent<HTMLAnchorElement> 거의 고정
  handleChange: (event: ChangeEvent<HTMLAnchorElement>) => 
    void;
}

// 자동차 컴포넌트 하위 컴포넌트로 이 컴포넌트가 들어감.
function CarDialogContent({car, handleChange} : DialogFormProps) {
  return (
    <div>CarDialogContent</div>
  )
}

export default CarDialogContent
```
현재 CarDialogContent 컴포넌트를 초기화했습니다.
현재 목표는 New Car 폼의 TextField를 렌더링하는 새 컴포넌트를 만들어서 Edit 폼에도 사용하는 것입니다.
그래서 TextField에 해당하는 부분을 자체 컴포넌트로 만들기 위해 CarDialogContent를 새로 만들었습니다. 그리고 props를 이용하여 컴포넌트에 car 객체와 handleChange 함수를 전달해야 합니다.(AddCar 컴포넌트에 정의돼있습니다.) 이를 위해서 DialogFormProps 

## 수정 기능 추가
Edit 버튼의 경우 위치가 New Car와 동일해서는 안됩니다. {id} 에 맞는 부분을 수정해야 하기 때문에, 각 row 옆에다 Edit 버튼을 추가할겁니다.


```tsx
import { ChangeEvent, useState } from "react";
import { Car, CarResponse } from "../types";
import { Dialog, DialogActions, DialogTitle } from "@mui/material";
import CarDialogContent from "./CarDialogContent";

type FormProps = {
  // 수정 시 특정 id값을 포함한 기존 차량 데이터
  cardata: CarResponse;
};

function EditCar({ cardata }: FormProps) {
  const [open, setOpen] = useState(false);

  // 초기값을 기존 차량 정보로 세팅
  const [car, setCar] = useState<Car>({
    brand: cardata.brand,
    model: cardata.model,
    color: cardata.color,
    registrationNumber: cardata.registrationNumber,
    modelYear: cardata.modelYear,
    price: cardata.price,
  });

  // 다이얼로그 열기
  const handleClickOpen = () => {
    setOpen(true);
    setCar({
      brand: cardata.brand,
      model: cardata.model,
      color: cardata.color,
      registrationNumber: cardata.registrationNumber,
      modelYear: cardata.modelYear,
      price: cardata.price,
    });
  };

  // 다이얼로그 닫기
  const handleClickClose = () => setOpen(false);

  // 수정 저장(여기서 나중에 PUT 요청으로 연결)
  const handleSave = () => {
    console.log("수정된 차량 데이터:", car);
    // 👉 나중에 updateCar(car, cardata._links.self.href) 같은 함수로 전송
    setOpen(false);
  };

  // 입력 변경 핸들러
  const handleChange = (event: ChangeEvent<HTMLInputElement>) => {
    setCar({ ...car, [event.target.name]: event.target.value });
  };

  return (
    <>
      <button onClick={handleClickOpen}>Edit</button>

      <Dialog open={open} onClose={handleClickClose}>
        <DialogTitle>Edit Car</DialogTitle>

        <CarDialogContent car={car} handleChange={handleChange} />

        <DialogActions>
          <button onClick={handleClickClose}>Cancel | 취소</button>
          <button onClick={handleSave}>Save | 저장</button>
        </DialogActions>
      </Dialog>
    </>
  );
}

export default EditCar;
```



이상의 EditCar 컴포넌트를 Carlist 컴포넌트에 집어넣었습니다.
특정 id값을 받아내기 위해서 GridCloDef 부분에 새로 컬럼 정의를 해줬고, renderCell을 이용하여 이상의 컴포넌트를 불러냈습니다.

이 부분까지 작성했을 때 , frontend 상에서 edit 버튼이 생겨나고, 그걸 클릭했을 때, modal 창이 뜬다는 것을 확인할 수 있습니다, 그 모달 창은 CarDialogContent 컴포넌트고, AddCar에서 사용했던 것과 동일하기 때문에 컴포넌트가 재사용성이 있다는 점을 확인할 수 있습니다.

차이점이 있다면 각각의 input 태그 내에 AddCar 컴포넌트에서는 전부 값이 비워져있던 반면에 EditCar에서는 어떤 roww를 클릭했는지에 따라 값이 서로 다르게 input태그 내에 들어가있었습니다.

이는 마찬가지로 renderCell이 (params)를 매개변수로 갖기 때문입니다. params.row를 하게 도면 테이블 내의 각 row들을 지치아게  됩니다.

이제 우리가 고려해야 하는 부분은 브러우저 상에서 수정된 자동차 정보를 백엔드로 보내줘야 한다는 점입니다. 
http://localhost:8080/api/{id} 로 PUT 요청을 보내게 될겁니다. 링크 삭제 할 때 href 값을 가져왔었기 때문에 동일한 기능을 한다는 것을 알 수 있습니다.

차이점이 있다면 deleteCar()는 id 값만 보내면 되는 반면에 updateCar()의 경우는 수정할 id 값과, 수정 내용이 전달되어야 하기 때문에 매개변수 개수가 달라지겠네요. 이 부분도 backend에서의 CarController를 확인하시면 됩니다.(cardata4)
여기 요청의 경우에는 내용이 필요하기 때문에 addCar()에서와 마찬가지로 'Content-Type':'application/json' headers가 필요합니다.

새로운 자료형 정의
```jsx
export type CraEntity = {
  car: Car;
  url: string;
}
```
이후 carapi.ts에서 함수를 생성해서 export 시키게 될 것이고, 그 함수는 EditCar 컴포넌트에서 사용하게 될 예정입니다.

```ts
// carapi.ts
export const updateCar = async ( // 비동기적으로
  // link: string, // 수정할 차량의 개별 리소스 URL(예: "https://api.example.com/api/cars/5")
  // car: Car // 수정할 차량 정보 객체(수정된 데이터)
  carEntity: CarEntity
): Promise<CarResponse> => {
  const response = await axios.put(carEntity.url, carEntity.car, {
    // PUT 요청으로 서버에 수정 데이터 전송 (PUT 요청이기 때문에 전체 내용이 다 들어가야 수정이 이루어짐)
    headers: {
      "Content-type": "application/json", // JSON 형식의 본문을 전송한다는 의미
    },
  });
  return response.data; // 서버가 반환한 수정된 차량 정보 반환
};
```
이상의 코드는 addCar() 함수와 비슷한 부분들이 있습니다.
하지만 axios.put() 요청에서의 첫번째 argument가 변수를 통해서 불러와진다는 점에서의 차이점이 있습니다. 왜냐하면 애초에 차량 정보가 DB에 저장되어있기 때문에 endpoint 가 id값까지 생성이 되어있습니다. 그리고 우리는 이것을 삭제 할 때 alert()을 통해서 herf값을 가지고 올 수 있다는 것을 확인했습니다. 그래서 굳이 `${import.meta.env.VITE_API_URL}/api/cars/${carEntity.car.id}`와 같은 형태로 작성하지 않아도 됩니다. 

## CSV로 데이터 내보내기
MUI 데이터 그리드에서 CSV(Comma seperated Value) 데이터 내보내기 기능을 지원하기 때문에 추가 라이브러리 설치가 필요 없습니다.

그럼 위에서 데이터그리드에서 가지고 올거라고 했으니까 기본적으로 Carlist 컴포넌트에서 작성할 것이라고 알 수 있겠네요.